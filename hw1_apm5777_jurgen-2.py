# -*- coding: utf-8 -*-
"""HW1-APM5777-JURGEN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LEBKqz0wd8InW15bPkMT3cMjgGC2ChBV
"""

# Projective Space (3,QQ) and Heights
from fractions import Fraction
from math import gcd
from functools import reduce
from itertools import product
from typing import Iterable, Tuple, Dict, List, Set

PointQ = Tuple[Fraction, Fraction, Fraction, Fraction]
PointZ = Tuple[int, int, int, int]



def _gcd_list(nums: Iterable[int]) -> int:
    """gcd of a list of integers (gcd([],)=0 by convention)."""
    nums = list(nums)
    if not nums:
        return 0
    return reduce(gcd, nums)

def _lcm(a: int, b: int) -> int:
    return abs(a*b) // gcd(a, b) if a and b else 0

def _lcm_list(nums: Iterable[int]) -> int:
    nums = list(nums)
    if not nums:
        return 1
    return reduce(_lcm, nums, 1)

def _first_nonzero_index(v: Iterable[int]) -> int:
    for i, x in enumerate(v):
        if x != 0:
            return i
    return -1

# STEP 1 — Represent points in P^3(Q)

def as_pointQ(x: Iterable) -> PointQ:
    """
    Convert an iterable of 4 entries to a tuple of Fractions.
    Accepts int or Fraction; floats are discouraged for exact arithmetic.
    """
    xs = list(x)
    if len(xs) != 4:
        raise ValueError("A point in P^3 must have exactly 4 coordinates.")
    return tuple(Fraction(z) for z in xs)  # type: ignore


# STEP 2 — Normalize a point (clear denominators, primitive, sign rule)

def normalize_point(p: Iterable) -> PointZ:
    """
    Normalize a point in P^3(Q) to a canonical primitive integer 4-tuple:
      1) Clear denominators.
      2) Divide by gcd of integers (primitive).
      3) Enforce sign rule: first nonzero entry is positive.
    Returns a 4-tuple of ints (all zeros is invalid).
    """
    q = as_pointQ(p)  # ensure 4 Fractions
    if all(x == 0 for x in q):
        raise ValueError("The zero vector does not define a projective point.")

    denoms = [x.denominator for x in q]
    L = _lcm_list(denoms)  # common multiple of denominators
    ints = [int(L * x) for x in q]  # guaranteed integers
    g = abs(_gcd_list(ints))
    if g == 0:
        # This happens only if ints is [0,0,0,0], which was excluded above
        raise ValueError("Normalization failed (unexpected all-zero).")

    # make primitive
    ints = [a // g for a in ints]

    # sign rule: first nonzero entry positive
    k = _first_nonzero_index(ints)
    if k == -1:
        # should not happen due to earlier checks
        raise ValueError("Normalization produced zero vector.")
    if ints[k] < 0:
        ints = [-a for a in ints]

    return tuple(ints)  # type: ignore

# STEP 3 — Height

def height(p: Iterable) -> int:
    """Height = max |x_i| of the normalized representative (primitive, sign-fixed)."""
    z = normalize_point(p)
    return max(abs(a) for a in z)

# STEP 4 — Build S: all normalized points of height ≤ H, with all allowed multiples

def enumerate_normalized_points_leq_H(H: int) -> Set[PointZ]:
    """
    Enumerate all canonical primitive integer reps (keys) with height ≤ H.
    We loop over integer boxes [-H..H]^4, filter primitive + sign rule,
    and collect their canonical representatives in a set (uniqueness guaranteed).
    """
    if H <= 0:
        return set()

    seen: Set[PointZ] = set()
    rng = range(-H, H+1)
    for x0, x1, x2, x3 in product(rng, repeat=4):
        if x0 == x1 == x2 == x3 == 0:
            continue
        g = _gcd_list([x0, x1, x2, x3])
        if abs(g) != 1:
            # not primitive => can be scaled down; skip to avoid duplicates
            continue

        rep = (x0, x1, x2, x3)
        k = _first_nonzero_index(rep)
        if k == -1:
            continue
        if rep[k] < 0:
            rep = tuple(-a for a in rep)

        # height already ≤ H because coords ∈ [-H,H]
        seen.add(rep)
    return seen


def allowed_multiples(rep: PointZ, H: int) -> List[PointZ]:
    """
    For a given primitive canonical representative 'rep',
    list all integer multiples λ*rep (λ ≠ 0) whose max |coord| ≤ H.
    Includes both positive and negative λ (as requested).
    """
    m = max(abs(a) for a in rep)
    kmax = H // m
    if kmax == 0:
        return []
    out = []
    for lam in range(-kmax, kmax+1):
        if lam == 0:
            continue
        out.append(tuple(lam * a for a in rep))
    return out


def build_S(H: int) -> Dict[PointZ, List[PointZ]]:
    """
    S maps each canonical normalized point (key) to all integer multiples within height ≤ H.
    Example: for [1,2,1,1] and H=10, allowed λ = ±1,...,±5 (since max coord is 2 ⇒ floor(10/2)=5).
    """
    keys = enumerate_normalized_points_leq_H(H)
    S: Dict[PointZ, List[PointZ]] = {}
    for rep in keys:
        S[rep] = allowed_multiples(rep, H)
    return S

# STEP 5 — Build NS: dictionary of exactly the normalized points

def build_NS(H: int) -> Dict[PointZ, int]:
    """
    NS contains exactly the normalized canonical points (keys).
    Value = height(rep) for convenience (you can store the rep itself if you prefer).
    """
    keys = enumerate_normalized_points_leq_H(H)
    NS: Dict[PointZ, int] = {rep: max(abs(a) for a in rep) for rep in keys}
    return NS

# STEP 6 — Exact-height counts

def exact_height_counts(NS: Dict[PointZ, int], H: int) -> Dict[int, int]:
    counts: Dict[int, int] = {h: 0 for h in range(1, H+1)}
    for rep, h in NS.items():
        if 1 <= h <= H:
            counts[h] += 1
    return counts


# STEP 7 — Table

def print_counts_table(counts: Dict[int, int]) -> None:
    H = max(counts) if counts else 0
    print("Height h | Number of normalized points")
    print("-------------------------------------")
    for h in range(1, H+1):
        print(f"{h:8d} | {counts[h]}")

def latex_counts_table(counts: Dict[int, int]) -> str:
    """Returns a LaTeX tabular you can paste into your report."""
    lines = [
        r"\begin{tabular}{r r}",
        r"\toprule",
        r"Height $h$ & \# normalized points \\",
        r"\midrule",
    ]
    for h in sorted(counts):
        lines.append(f"{h} & {counts[h]} \\\\")
    lines += [r"\bottomrule", r"\end{tabular}"]
    return "\n".join(lines)

# Check if a point is in the projective space

def in_S(S: Dict[PointZ, List[PointZ]], t: Iterable) -> bool:
    """
    Check if a given tuple t (int or Fraction entries, length 4)
    appears among the stored multiples under the correct normalized key.
    """
    z_given = normalize_point(t)          # canonical key of its projective class
    # Figure out which multiple of the key 'z_given' equals the raw integer tuple 't'
    # We should compare against S[z_given] but using the original *integer* scaled version.
    # Ensure we bring 't' to an integer tuple (clear denominators only; no primitive scaling).
    q = as_pointQ(t)
    L = _lcm_list([x.denominator for x in q])
    raw_int = tuple(int(L * x) for x in q)
    if z_given not in S:
        return False
    return raw_int in S[z_given]

# Number of ptojective points until height 10
if __name__ == "__main__":
    H = 10

    # Step 4: Build S
    S = build_S(H)

    # Step 5: Build NS
    NS = build_NS(H)

    # Step 6: Height counts
    counts = exact_height_counts(NS, H)

    # Step 7: Show table
    print_counts_table(counts)

S = build_S(10)

print("Key:", (1,2,1,1))
print("All generating tuples (height ≤ 10):")
print(S.get((1,2,1,1), []))

if __name__ == "__main__":
    H = 10


    # === NEW: all height-1 tuples ===
    pts_h1 = [p for p in NS if height(p) == 1]
    print(f"\nTotal projective points with height 1: {len(pts_h1)}\n")

    for t in pts_h1:
        print(tuple(t))



# Demo: your example [1, 2, 1, 1]
    example = (1/2, 2/2, 1/2, 1/2)
    rep = normalize_point(example)  # should be (1,2,1,1)
    print("\nExample representative:", rep)
    print(f"Allowed multiples for {rep} with H={H}:")
    print(S[rep])

    # Quick membership checks
    print("\nMembership checks in S:")
    tests = [
        (1, 2, 1, 1),   # same
        (-1, -2, -1, -1),  # same projective point, negative lambda
        (5, 10, 5, 5),  # λ=5
        (2, 4, 12, 2),
    ]
    for t in tests:
        print(f"{t}: {in_S(S, t)}")



"""# Number of rational projective points in $P^n(Q) $ of height $≤ H $

$ C_{{n} ^{\leq}(H)} = \frac{1}{2} \sum_{d=1}^{H}
\mu(d) \,\Bigl( \bigl(2\lfloor H/d \rfloor + 1\bigr)^{\,n+1} - 1 \Bigr),
$

#Number of points of exact height H
$
A_n(H) \;=\; C_{n^{\leq}(H)} \;-\; C_{n^{\leq}(H-1)}.
$

"""

# formula in python

from math import gcd
from functools import reduce

def mobius(n: int) -> int:
    """Möbius function."""
    if n == 1: return 1
    mu, x, p = 1, n, 2
    while p * p <= x:
        if x % p == 0:
            x //= p
            if x % p == 0:
                return 0
            mu *= -1
        p += 1 if p == 2 else 2
    if x > 1: mu *= -1
    return mu

def count_PnQ_leqH(n: int, H: int) -> int:
    """Count projective rational points of height ≤ H in P^n(Q)."""
    if H <= 0: return 0
    total = 0
    for d in range(1, H+1):
        t = 2*(H//d) + 1
        total += mobius(d) * (t**(n+1) - 1)
    return total // 2

def count_PnQ_exactH(n: int, H: int) -> int:
    """Count projective rational points of exact height H."""
    return count_PnQ_leqH(n, H) - count_PnQ_leqH(n, H-1)

# Examples for P^3(Q)
for H in [1, 2, 3,4,5,6,7,8,9,10]:
    print(f"P^3(Q), height ≤ {H}: {count_PnQ_leqH(3, H)} points")
    print(f"P^3(Q), exact height {H}: {count_PnQ_exactH(3, H)} points")